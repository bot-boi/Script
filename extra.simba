{$include_once Script/script.simba}
{$include_once Script/extra/finders.simba}

procedure DoDialogue(options: Array of Int32); // do chat by chat option indices, not strings :) convenient when paired with quest quick guides
var
  option: Int32;
  chatOption: TRSChatOption;
  chatOptions: TRSChatOptionArray;

begin
  writeln('DoDialogue-: Starting.');
  Script.Walker.WaitPlayerMoving();
  Wait(RandomRange(1500, 3500));

  while Chatbox.ClickContinue() do Chatbox.PleaseWait(); // case: empty option array

  for option in options do begin
    while Chatbox.ClickContinue() do Chatbox.PleaseWait();
    Chatbox.PleaseWait();
    Wait(1000, 5000);
    chatOptions := Chatbox.GetOptions();

    {$IFDEF DEBUG}
      writeln('DoDialogue-: chat options!');
      for chatOption in chatOptions do begin
        writeln(chatOption.Text);
      end;
      writeln('DoDialogue-: end chat options!');
    {$ENDIF}

    writeln(chatOptions[option].Text);
    Chatbox.ClickOption([chatOptions[option].Text]);
    Chatbox.PleaseWait();
  end;
  writeln('DoDialogue-: Done selecting options.');
  while Chatbox.ClickContinue() do Chatbox.PleaseWait();
  writeln('DoDialogue-: Done.');
end;

procedure TravelTo(p: TPoint; maxDist: Integer = 16; timeout:Integer = ONE_MINUTE*5);
var
  myPos: TPoint;
  t: TCountdown;

begin
  t.Init(timeout);
  repeat
    Script.Walker.WebWalk(p);
    myPos := Script.Walker.GetMyPos();
  until (myPos.DistanceTo(p) <= maxDist) or t.IsFinished();
  while Minimap.IsPlayerMoving(100) do Wait(Random(50));
end;

procedure WalkToPos(p: TPoint; maxDist: Integer = 16; timeout:Integer = ONE_MINUTE*5);
var
  myPos: TPoint;
  t: TCountdown;

begin
  t.Init(timeout);
  repeat                                 // same as travelto but doesnt use webwalking
    Script.Walker.WalkPath([p]);
    myPos := Script.Walker.GetMyPos();
  until (myPos.DistanceTo(p) <= maxDist) or t.IsFinished();
  while Minimap.IsPlayerMoving(100) do Wait(Random(50));
end;

// ripped from a post by flight                       1 in 4 chance of miss by default
procedure HumanMMouse(eX, eY, MouseSpeed: Integer; missChance: Integer = 4);
var
  randSpeed: extended;
  X,Y,A,Dist,MP: integer;
begin
  A := MouseSpeed;
  GetMousePos(X, Y);
  Dist := Distance(X, Y, eX, eY);
  MP := Round(Dist/150);
  if MP < 0 then
    MP := 1;

  randSpeed := (random(MouseSpeed) / 2.0 + MouseSpeed) / 10.0;
  if Random(missChance) = 0 then begin
    Mouse.Move(RandomRange(eX-(A*MP), eX+(A*MP)), RandomRange(eY-(A*MP), eY+(A*MP)));
  end;

  GetMousePos(X, Y);
  Mouse.Move(eX, eY);
  MouseSpeed := A;
end;

// move mouse to a random minimap dot on mainscreen
// this should be in finder, uses HumanMMouse :(
procedure HoverRandomDot(dots: set of EMinimapDotType; offset: TPoint);
var
  NPCMinimap:    TPointArray; // position of dots on minimap
  NPCMainscreen: TPointArray; // position of dots on mainscreen
  NPCTiles:      TBoxArray;   // tiles on mainscreen that contain dots
  tile, target:  TBox;
  poin, rp:      TPoint;      // point, random point
begin
  NPCMinimap := Minimap.GetDots(dots); //  get dots, map them to ms as tbox
  NPCMinimap.Offset(offset);

  for poin in NPCMinimap do begin
    tile := Minimap.PointToMsBox(poin);
    if Mainscreen.GetBounds().Contains(tile) then begin
      NPCTiles += Minimap.PointToMsBox(poin);
    end;
  end;

  if High(NPCTiles) <= -1 then Exit;

  target := NPCTiles[Random(Length(NPCTiles))];
  rp     := SRL.RandomPoint(target);  // favors center

  {$IFDEF DEBUG}
    Bitmap.FromClient();
    Bitmap.DrawBox(target, False, $FFFFFF);
    Bitmap.DrawCross(rp, 5, $FFFFFF);
    Bitmap.UpdateDebugImage();
  {$ENDIF}

  HumanMMouse(rp.X, rp.Y, RandomRange(10, 20));
end;

// test if player is near an hpbar
// better than incombat if no other players are around
function NearCombat(distance: Integer): Boolean;
var
  centerPoint: TPoint;
  HPBars: THPBarArray;
  HPBar:  THPBar;

begin
  centerPoint := Mainscreen.GetMiddle();
  HPBars := Mainscreen.FindHPBars(Mainscreen.GetBounds());

  for HPBar in HPBars do begin
    if (centerPoint.DistanceTo(HPBar.Bounds.Middle()) <= distance) then begin
      Exit(True);
    end;
  end;
  Exit(False);
end;

// test if your player is near another player
// distance on mmap is used, keep this in mind. 4px ~= 1 tile
function NearPlayer(minDistance: Integer): Boolean;
var
  cp, pp: TPoint; // center point, player point
  pps: TPointArray = []; // player points... pps lul
begin
  cp := Minimap.GetMiddle();
  pps := Minimap.GetDots([MMDotPlayer]);
  pps.Offset([2, 2]);

  for pp in pps do begin
    if cp.DistanceTo(pp) <= minDistance then begin
      Exit(True);
    end;
  end;
  Exit(False);
end;

// attempts to click an atpa with uptext for timeout amount of time
function TryClickATPA(atpa: T2DPointArray; uptext: TStringArray; timeout: Integer = ONE_SECOND*2): Boolean;
var
  tpa:  TPointArray;
  rp:   TPoint; // random point
  T: TCountdown;

begin
  Result := False;
  T.Init(timeout);
  while (not T.IsFinished()) do begin
    for tpa in atpa do begin            // this could be a lot better, and less botty
      rp := tpa[Random(Length(tpa))];
      HumanMMouse(rp.X, rp.Y, RandomRange(10, 20));
      if Mainscreen.IsUpText(uptext) then begin
        Result := Mouse.Click(ctRed);
        if Result then Exit(Result);
      end;
    end;
  end;
end;

// check if player in combat.  this would be way more effective if i would just use runelite
function InCombat(): Boolean;
begin
  Result := Length(Mainscreen.FindHPBars(Mainscreen.GetPlayerBox)) > 0;
end;

procedure TPointArray.Shuffle();
var
  p, r: TPoint; // r = random point
begin
  for p in Self do begin
    r := Self[Random(High(Self))];
    tSwap(p, r);
  end;
end;

// randomizes a point based on range
function RandomizePoint(p: TPoint; range: Integer): TPoint;
var
  hx, hy, lx, ly, rx, ry: Integer; // high x, low x, random/result x
begin
  hx := p.x + range div 2;
  hy := p.y + range div 2;
  lx := p.x - range div 2;
  ly := p.y - range div 2;
  rx := RandomRange(lx, hx);
  ry := RandomRange(ly, hy);
  Result := Point(rx, ry);
end;


// add a raw path to a rswalker webgraph
procedure TWebGraph.AppendRaw(path: T2DIntArray);
var
  rawNode: TIntArray;
  p: TPoint;
  i: Integer = -1;
begin
  for rawNode in path do begin
    p := Point(rawNode[0], rawNode[1]);
    Self.AddNode(p, i);
    Inc(i);
  end;
end;

// add path to a rswalker webgraph
procedure TWebGraph.Append(path: TPointArray);
var
  p: TPoint;
  i: Integer = -1;
begin
  for p in path do begin
    Self.AddNode(p, i);
    Inc(i);
  end;
end;
